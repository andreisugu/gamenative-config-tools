<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameNative Config Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #4ec9b0;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #858585;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        textarea {
            width: 100%;
            flex: 1;
            min-height: 400px;
            padding: 15px;
            background-color: #252526;
            color: #d4d4d4;
            border: 2px solid #3e3e42;
            border-radius: 5px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #4ec9b0;
        }

        textarea::placeholder {
            color: #6a6a6a;
        }

        .button-container {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 12px 24px;
            background-color: #0e639c;
            color: #ffffff;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #1177bb;
        }

        button:active {
            background-color: #0d5a8f;
        }

        .error-message {
            color: #f48771;
            margin-top: 10px;
            font-size: 14px;
            display: none;
        }

        .success-message {
            color: #4ec9b0;
            margin-top: 10px;
            font-size: 14px;
            display: none;
        }

        .info {
            background-color: #2d2d30;
            padding: 15px;
            border-left: 3px solid #4ec9b0;
            margin-bottom: 20px;
            border-radius: 3px;
        }

        .info h3 {
            color: #4ec9b0;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .info p {
            color: #b0b0b0;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .info code {
            background-color: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #ce9178;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>GameNative Config Converter</h1>
        <p class="subtitle">Converts raw configurations into usable game configurations</p>
        
        <div class="info">
            <h3>How to use:</h3>
            <p>
                Enter your configuration with alternating key-value pairs on separate lines.<br>
                Line N = Key, Line N+1 = Value<br>
                Values like <code>true</code>/<code>false</code> will be converted to booleans, and numeric strings will be converted to numbers.
            </p>
        </div>

        <textarea id="inputText" placeholder="wineVersion&#10;8.0&#10;graphicsDriverAdreno&#10;turnip&#10;showFPS&#10;true&#10;envVars&#10;WINE_DEBUG=warn"></textarea>
        
        <div class="button-container">
            <button id="downloadBtn" onclick="convertAndDownload()">Download Clean Config</button>
        </div>
        
        <div id="errorMessage" class="error-message"></div>
        <div id="successMessage" class="success-message"></div>
    </div>

    <script>
        const BUTTON_INDEX_MAP = {
            "A": "0", "B": "1", "X": "2", "Y": "3",
            "L1": "4", "R1": "5", "SELECT": "6", "START": "7",
            "MENU": "8", "L2": "9", "R2": "10", "L3": "11",
            "R3": "12", "DPAD UP": "13", "DPAD DOWN": "14",
            "DPAD LEFT": "15", "DPAD RIGHT": "16"
        };

        // Derive BUTTON_KEYS from BUTTON_INDEX_MAP to maintain consistency
        const BUTTON_KEYS = new Set(Object.keys(BUTTON_INDEX_MAP));

        const EXCLUDED_KEYS = new Set([
            "avg fps", "session length sec", "appVersion", 
            "imgVersion", "config changed", "discord support prompt shown", 
            "profileId"  // Junk metadata fields excluded from config output
        ]);

        const STRING_ONLY_KEYS = new Set([
            "wineVersion", "box86Version", "box64Version", "fexcoreVersion", 
            "graphicsDriverVersion", "graphicsDriverConfig", "dxwrapperConfig", "id"
        ]);
        
        const STEAM_ID_PREFIX = "STEAM_";
        const NUMERIC_APP_ID_PATTERN = /^\d+$/;

        const KNOWN_KEYS = new Set([
            "id", "name", "drives", "lc all", "cpuList", "envVars", "showFPS", 
            "useDRI3", "emulator", "execArgs", "forceDlc", "language", "rcfileId", 
            "dxwrapper", "extraData", "profileId", "appVersion", "imgVersion", 
            "audioDriver", "box64Version", "desktopTheme", "wincomponents", 
            "config changed", "fexcoreVersion", "graphicsDriver", "sharpnessLevel", 
            "sharpnessEffect", "sharpnessDenoise", "startupSelection", "graphicsDriverAdreno",
            "lastInstalledMainWrapper", "discord support prompt shown", "inputType", 
            "steamType", "wow64Mode", "screenSize", "box64Preset", "box86Preset", 
            "installPath", "wineVersion", "box86Version", "cpuListWoW64", "useLegacyDRM", 
            "fexcorePreset", "midiSoundFont", "executablePath", "needsUnpacking", 
            "dxwrapperConfig", "launchRealSteam", "sessionMetadata", "avg fps", 
            "session length sec", "touchscreenMode", "containerVariant", "dinputMapperType", 
            "sdlControllerAPI", "allowSteamUpdates", "controllerMapping", "disableMouseInput", 
            "primaryController", "emulateKeyboardMouse", "graphicsDriverConfig", 
            "graphicsDriverVersion", "controllerEmulationBindings"
        ]);

        function parseValue(value, key) {
            // Trim whitespace
            const trimmedValue = value.trim();
            
            // Handle drives: remove all whitespace per spec (LETTER:PATHLETTER2:PATH with zero spaces)
            if (key === "drives") {
                return trimmedValue.replace(/\s+/g, '');
            }
            
            // Handle extraData and sessionMetadata: parse as JSON objects
            if (key === "extraData" || key === "sessionMetadata") {
                // Handle empty string or "null" string
                if (trimmedValue === "" || trimmedValue === "null") {
                    return null;
                }
                // Try to parse as JSON
                try {
                    return JSON.parse(trimmedValue);
                } catch (e) {
                    // If parsing fails, return null to maintain Object type
                    return null;
                }
            }
            
            // Skip conversion for version-related keys
            if (key && STRING_ONLY_KEYS.has(key)) {
                return trimmedValue;
            }
            
            // Convert "true" to boolean true
            if (trimmedValue === 'true') {
                return true;
            }
            
            // Convert "false" to boolean false
            if (trimmedValue === 'false') {
                return false;
            }
            
            // Check if it's a number
            if (/^-?\d+(\.\d+)?$/.test(trimmedValue)) {
                const numValue = Number(trimmedValue);
                // Only convert if it's a valid number (not NaN or Infinity)
                if (!isNaN(numValue) && isFinite(numValue)) {
                    return numValue;
                }
            }
            
            // Return as string if no conversion applies
            return trimmedValue;
        }

        function convertToJSON(inputText) {
            const lines = inputText.split('\n').filter(line => line.trim() !== '');
            
            if (lines.length === 0) {
                throw new Error('Input is empty. Please provide key-value pairs.');
            }
            
            const config = {};
            const bindings = {};
            let i = 0;
            
            while (i < lines.length) {
                const currentLine = lines[i].trim();
                
                // Check if current line is a button key
                if (BUTTON_KEYS.has(currentLine)) {
                    const buttonKey = currentLine;
                    const buttonIndex = BUTTON_INDEX_MAP[buttonKey];
                    
                    // Defensive check for future extensibility (currently unreachable since BUTTON_KEYS is derived from BUTTON_INDEX_MAP)
                    if (buttonIndex === undefined) {
                        i++;
                        continue;
                    }
                    
                    // Peek at the next line
                    const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : undefined;
                    const nextLineIsKnownKey = nextLine !== undefined && KNOWN_KEYS.has(nextLine);
                    const nextLineIsButtonKey = nextLine !== undefined && BUTTON_KEYS.has(nextLine);
                    
                    // If next line is also a known key, button key, or undefined, current button has empty value
                    if (nextLine === undefined || nextLineIsKnownKey || nextLineIsButtonKey) {
                        bindings[buttonIndex] = "";
                        i++; // Move to next line
                    } else {
                        // Next line is the value for this button
                        bindings[buttonIndex] = parseValue(nextLine, buttonKey);
                        i += 2; // Skip both button key and value
                    }
                }
                // Check if current line is a known key
                else if (KNOWN_KEYS.has(currentLine)) {
                    const key = currentLine;
                    
                    // Skip excluded keys (junk metadata)
                    if (EXCLUDED_KEYS.has(key)) {
                        // Peek at the next line to determine if we need to skip a value
                        const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : undefined;
                        const nextLineIsKnownKey = nextLine !== undefined && KNOWN_KEYS.has(nextLine);
                        const nextLineIsButtonKey = nextLine !== undefined && BUTTON_KEYS.has(nextLine);
                        
                        // If next line is also a known key, button key, or undefined, skip only current line
                        if (nextLine === undefined || nextLineIsKnownKey || nextLineIsButtonKey) {
                            i++; // Skip the excluded key
                        } else {
                            // Skip both the excluded key and its value
                            i += 2;
                        }
                    } else {
                        // Process non-excluded keys
                        // Rename "lc all" to "lc_all" for property name compatibility
                        let configKey = key;
                        if (key === "lc all") {
                            configKey = "lc_all";
                        }
                        
                        // Peek at the next line
                        const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : undefined;
                        const nextLineIsKnownKey = nextLine !== undefined && KNOWN_KEYS.has(nextLine);
                        const nextLineIsButtonKey = nextLine !== undefined && BUTTON_KEYS.has(nextLine);
                        
                        // If next line is also a known key, button key, or undefined, current key has empty value
                        if (nextLine === undefined || nextLineIsKnownKey || nextLineIsButtonKey) {
                            config[configKey] = parseValue("", key);
                            i++; // Move to next line
                        } else {
                            // Next line is the value for this key
                            config[configKey] = parseValue(nextLine, key);
                            i += 2; // Skip both key and value
                        }
                    }
                } else {
                    throw new Error(`Unknown key "${currentLine}" at position ${i + 1}.`);
                }
            }
            
            // Add bindings to config if any were collected
            if (Object.keys(bindings).length > 0) {
                config.controllerEmulationBindings = bindings;
            }
            
            return config;
        }

        async function fetchSteamGameName(appId) {
            try {
                // NOTE: This function uses public CORS proxy services to access the Steam API
                // since direct browser requests are blocked by CORS policy.
                // These proxies could be unavailable or compromised. Response validation
                // is performed to mitigate security risks.
                const proxies = [
                    `https://api.allorigins.win/raw?url=`,
                    `https://corsproxy.io/?`,
                ];
                
                const apiUrl = `https://store.steampowered.com/api/appdetails?appids=${appId}`;
                
                for (const proxy of proxies) {
                    try {
                        const response = await fetch(proxy + encodeURIComponent(apiUrl));
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        
                        // Validate response structure to prevent malicious data injection
                        if (!data || typeof data !== 'object') {
                            console.warn(`Invalid response from proxy ${proxy}`);
                            continue;
                        }
                        
                        // Check if the API returned valid data
                        if (data[appId] && 
                            typeof data[appId] === 'object' &&
                            data[appId].success === true && 
                            data[appId].data && 
                            typeof data[appId].data === 'object' &&
                            typeof data[appId].data.name === 'string') {
                            // Sanitize the game name to prevent XSS attacks
                            const gameName = data[appId].data.name;
                            const sanitized = gameName
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;')
                                .replace(/"/g, '&quot;')
                                .replace(/'/g, '&#x27;')
                                .replace(/\//g, '&#x2F;');
                            return sanitized;
                        }
                    } catch (proxyError) {
                        console.warn(`Proxy ${proxy} failed:`, proxyError);
                        continue;
                    }
                }
                
                return null;
            } catch (error) {
                console.error('Failed to fetch Steam game name:', error);
                return null;
            }
        }

        async function convertAndDownload() {
            const inputText = document.getElementById('inputText').value;
            const errorMessage = document.getElementById('errorMessage');
            const successMessage = document.getElementById('successMessage');
            
            // Hide previous messages
            errorMessage.style.display = 'none';
            successMessage.style.display = 'none';
            
            try {
                const jsonData = convertToJSON(inputText);
                
                // Extract Steam App ID from the id field and fetch game name
                let containerName = "Imported Config";
                if (jsonData.id && typeof jsonData.id === 'string' && jsonData.id.startsWith(STEAM_ID_PREFIX)) {
                    const appId = jsonData.id.slice(STEAM_ID_PREFIX.length);
                    
                    // Validate that appId is numeric before making API call
                    if (appId && NUMERIC_APP_ID_PATTERN.test(appId)) {
                        const gameName = await fetchSteamGameName(appId);
                        if (gameName) {
                            containerName = gameName;
                        }
                    }
                }
                
                // Wrap the config in the required metadata structure for Import feature
                const finalOutput = {
                    "version": 1,
                    "exportedFrom": "GameNative",
                    "timestamp": Date.now(),
                    "containerName": containerName,
                    "config": jsonData
                };
                
                const jsonString = JSON.stringify(finalOutput, null, 2);
                
                // Create a blob and download
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'config.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show success message
                successMessage.textContent = 'JSON file downloaded successfully!';
                successMessage.style.display = 'block';
            } catch (error) {
                // Show error message
                errorMessage.textContent = 'Error: ' + error.message;
                errorMessage.style.display = 'block';
            }
        }

        // Allow Enter key in textarea (default behavior)
        document.getElementById('inputText').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                convertAndDownload();
            }
        });
    </script>
</body>
</html>
